// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE
'use strict';

var Jest                    = require("bs-jest/lib/js/src/jest.js");
var Most                    = require("../most.js");
var Most$1                  = require("most");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function noOp() {
  return /* () */0;
}

function combineArray(coll, el) {
  coll.push(el);
  return /* () */0;
}

function combineList(collRef, el) {
  collRef[0] = /* :: */[
    el,
    collRef[0]
  ];
  return /* () */0;
}

function asyncExpectToEqual(expected, actual) {
  return Promise.resolve(Jest.Expect[/* toEqual */11](expected)(Jest.Expect[/* expect */0](actual)));
}

var Helpers = /* module */[
  /* noOp */noOp,
  /* combineArray */combineArray,
  /* combineList */combineList,
  /* asyncExpectToEqual */asyncExpectToEqual
];

Jest.testPromise("empty", (function () {
        var empty = Most$1.empty();
        var success = function () {
          return asyncExpectToEqual(/* true */1, /* true */1);
        };
        return empty.observe((function () {
                        throw [
                              Caml_builtin_exceptions.failure,
                              "this shouldn't happen"
                            ];
                      })).then(success);
      }));

Jest.testAsync("just", (function (done_) {
        var success = function (result) {
          return Curry._1(done_, Jest.Expect[/* toBe */1]("asdf")(Jest.Expect[/* expect */0](result)));
        };
        Most$1.just("asdf").observe(success);
        return /* () */0;
      }));

Jest.testPromise("from", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* int array */[
                      1,
                      2
                    ], result);
        };
        return Most$1.from(/* int array */[
                        1,
                        2
                      ]).observe(combine).then(success);
      }));

Jest.testPromise("concat", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var s1 = Most$1.from(/* int array */[
              1,
              2,
              3
            ]);
        var s2 = Most$1.from(/* int array */[
              4,
              5,
              6
            ]);
        var success = function () {
          return asyncExpectToEqual(/* array */[
                      1,
                      2,
                      3,
                      4,
                      5,
                      6
                    ], result);
        };
        return s1.concat(s2).observe(combine).then(success);
      }));

Jest.testPromise("startWith", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var s = Most$1.from(/* int array */[
              1,
              2,
              3
            ]);
        var success = function () {
          return asyncExpectToEqual(/* int array */[
                      0,
                      1,
                      2,
                      3
                    ], result);
        };
        return Most.startWith(0, s).observe(combine).then(success);
      }));

Jest.testPromise("unfold", (function () {
        var result = [/* [] */0];
        var combine = function (el) {
          result[0] = /* :: */[
            el,
            result[0]
          ];
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* :: */[
                      3,
                      /* :: */[
                        2,
                        /* :: */[
                          1,
                          /* [] */0
                        ]
                      ]
                    ], result[0]);
        };
        return Most.unfold((function (prev) {
                          if (prev < 3) {
                            return /* Value */[
                                    prev + 1 | 0,
                                    prev + 1 | 0
                                  ];
                          } else {
                            return /* Done */0;
                          }
                        }), 0).observe(combine).then(success);
      }));

Jest.testPromise("fromList", (function () {
        var result = [/* [] */0];
        var combine = function (param) {
          return combineList(result, param);
        };
        var success = function () {
          return asyncExpectToEqual(/* :: */[
                      3,
                      /* :: */[
                        2,
                        /* :: */[
                          1,
                          /* [] */0
                        ]
                      ]
                    ], result[0]);
        };
        return Most.fromList(/* :: */[
                        1,
                        /* :: */[
                          2,
                          /* :: */[
                            3,
                            /* [] */0
                          ]
                        ]
                      ]).observe(combine).then(success);
      }));

Jest.testPromise("map", (function () {
        var result = /* array */[];
        var combineResult = function (param) {
          result.push(param);
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* int array */[
                      2,
                      4,
                      6
                    ], result);
        };
        return Most$1.map((function (n) {
                          return (n << 1);
                        }), Most$1.from(/* int array */[
                            1,
                            2,
                            3
                          ])).observe(combineResult).then(success);
      }));

Jest.testPromise("constant", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* int array */[
                      10,
                      10,
                      10
                    ], result);
        };
        return Most$1.constant(10, Most$1.from(/* int array */[
                            1,
                            2,
                            3
                          ])).observe(combine).then(success);
      }));

Jest.testPromise("scan", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* array */[
                      0,
                      1,
                      3,
                      6,
                      10
                    ], result);
        };
        return Most$1.scan((function (accum, n) {
                          return accum + n | 0;
                        }), 0, Most$1.from(/* int array */[
                            1,
                            2,
                            3,
                            4
                          ])).observe(combine).then(success);
      }));

Jest.testPromise("flatMap", (function () {
        var result = /* array */[];
        var combine = function (param) {
          result.push(param);
          return /* () */0;
        };
        var success = function () {
          return asyncExpectToEqual(/* array */[
                      0,
                      1,
                      0,
                      2,
                      0,
                      3,
                      0,
                      4
                    ], result);
        };
        return Most$1.flatMap((function (x) {
                          return Most$1.from(/* int array */[
                                      0,
                                      x
                                    ]);
                        }), Most$1.from(/* int array */[
                            1,
                            2,
                            3,
                            4
                          ])).observe(combine).then(success);
      }));

exports.Helpers = Helpers;
/*  Not a pure module */
